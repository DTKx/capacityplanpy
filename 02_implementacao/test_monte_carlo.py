import numpy as np
from numba import jit


@jit(nopython=True, nogil=True, fastmath=True)
def calc_triangular_dist(demand_distribution, num_monte):
    # Calculates triangular distributions
    return np.random.triangular(demand_distribution[0], demand_distribution[1], demand_distribution[2], size=num_monte)


def main():
    # Goal find distribution_of_median_of_sum_available_products(np.median(np.sum(available_products)), the median from the 1000 Monte Carlo Simulations ): available_products=stock-demand (Each demand is generated by a Monte Carlo simulation 1000 times, therefore I will have 1000 demand arrays and consequently I will have a distribution of 1000 values of available products)
    # Input
    demand_triangular = np.array(
        [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, (4.5, 5.5, 8.25)], [(2.1, 3.1, 4.65), 0.0, 0.0, (4.5, 5.5, 8.25)],]
    )  # Each column represents a product, each row a month. Tuples are for triangular distribution (min,mean,max)
    stock = np.array([[30, 30, 30, 22],[30, 30, 30, 22],[30, 30, 30, 22]])  # Stock of available products, Each column represents a product, each row a month.
    num_sim_monte_carlo = 1000

    # Problem 1) How to unpack effectively each array of demand from simulation? Given that in my real case I would have 70 tuples to perform the Monte Carlo simulation?

    row, col = demand_triangular.shape
    index_demand_not_0 = np.where(demand_triangular != 0)  # Index of values that are not zeros,therefore my tuples for triangular distribution

    dict_demand_values_simulations = {}  # Stores 1000 values of each demand value, coming the tuple.
    triangular_len = len(demand_triangular[index_demand_not_0])  # Length of rows to calculate triangular
    for k in range(0, triangular_len):  # loop per values to simulate
        print(demand_triangular[index_demand_not_0][k])
        dict_demand_values_simulations[k] = calc_triangular_dist(demand_triangular[index_demand_not_0][k], num_sim_monte_carlo)

    sums_available_simulations = np.zeros(shape=num_sim_monte_carlo)  # Stores each 1000 different sums of available, generated by unpacking the dict_demand_velues_simulations
    for j in range(0, num_sim_monte_carlo):  # loop per number of monte carlo simulations
        demand_j = np.zeros(shape=demand_triangular.shape,dtype=float)
        for k in range(0, triangular_len):  # loop per values to simulate
            # print(demand_j)
            demand_j[index_demand_not_0[0][k],index_demand_not_0[1][k]] = dict_demand_values_simulations[k][j]  # Populates all simulated values from simulations in each 1000 demand array. 
            # print(demand_j)
        available=stock-demand_j
        available[available<0]=0#Fixes with values are negative
        sums_available_simulations[j] = np.sum(available)  # Stores available for each simulation
    print("Median of distribution of available is: ", np.median(sums_available_simulations))


if __name__ == "__main__":
    main()
